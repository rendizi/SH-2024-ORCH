import axios from "axios";
import cloudscraper from "cloudscraper";
import { exec } from "child_process";
import prisma from "./prisma";
import jwt from "jsonwebtoken"
import bcrypt from "bcrypt"
import { connect } from "http2";
export const de = async() => {
    await prisma.agent.deleteMany({})
}

export const fetchLatest = async () => {
    try {
      console.log("Starting fetchLatest process...");
  
      // Step 1: Execute the curl command
      const curlCommand = `curl -X POST https://sploitus.com/search -H "Content-Type: application/json" -d '{"type":"exploits","sort":"default","query":"POC","title":false,"offset":0}'`;
      console.log("Executing curl command to fetch latest exploits...");
      
      const response = await executeCurl(curlCommand);
      console.log("Curl command executed successfully. Parsing response...");
  
      const responseData = JSON.parse(response);
      console.log(`Fetched ${responseData.exploits_total} exploits from Sploitus.`);
  
      // Step 2: Transform exploits
      const transformedExploits = transformExploits(responseData);
      console.log("Transformed exploits:", transformedExploits);
  
      // Step 3: Determine technologies
      console.log("Determining technologies associated with exploits...");
      const technologiesString = await determineTechnology(responseData);
      const technologies = JSON.parse(technologiesString);
      console.log("Parsed technologies:", technologies);
  
      // Step 4: Save transformed exploits to the database
      console.log("Saving exploits to the database...");
      for (const exp of transformedExploits) {
        try {
          await prisma.exploit.create({
            data: exp,
          });
          console.log(`Saved exploit: ${exp.vulnerability_id}`);
        } catch (err: any) {
          console.error(`Failed to save exploit: ${exp.vulnerability_id}`, err.message);
        }
      }
  
      // Step 5: Generate tasks for each technology and service
      const toDo: Array<{ service: any; id: string }> = [];
      console.log("Generating tasks for technologies...");
  
      for (const techn of technologies) {
        console.log(`Processing technology ID: ${techn.id}`);
        for (const n of techn.technologies) {
          console.log(`Searching for services matching technology: ${n}`);
          const potentialServices = await prisma.technology.findMany({
            where: {
              name: {
                contains: n,
                mode: "insensitive",
              },
            },
          });
          console.log(`Found ${potentialServices.length} services for technology: ${n}`);
  
          for (const service of potentialServices) {
            console.log(service.id)
            toDo.push({
              service: service.serviceId,
              id: techn.id,
            });
            console.log(`Added task for service: ${service.name}`);
          }
        }
      }
      console.log(`Generated ${toDo.length} tasks.`);
  
      // Step 6: Fetch alive agents
      console.log("Fetching alive agents...");
      const agents = await prisma.agent.findMany({
        where: {
          status: "alive",
        },
      });
      console.log(`Found ${agents.length} alive agents.`);
  
      // Step 7: Distribute tasks to agents
      console.log("Distributing tasks to agents...");
      for (const task of toDo) {
        console.log(`Processing task for technology ID: ${task.id} and service: ${task.service.name}`);
        for (const agent of agents) {
          try {
            console.log(`Sending task to agent ID: ${agent.id}, IP: ${agent.ip}`);
            const exploit = await prisma.exploit.findFirst({
              where: {
                vulnerability_id: task.id,
              },
            });
  
            if (!exploit) {
              console.error(`No exploit found for task ID: ${task.id}`);
              continue;
            }        

            if (!task.service){
              console.log("no id")
                break  
            }

            console.log(task.service)

            const ser = await prisma.service.findFirst({
              where: {
                id: task.service 
              }
            })

            if (!ser){
              console.log(task.service)
              console.log("Noservice")
              break 
            }

            const report = await prisma.report.create({data: {
                agent: {connect:{id: agent.id}},
                service: {connect:{id: ser.id}},
                exploit: {connect: {id: exploit.id}},
                verdict: "proccessing..."
            }})

            const token = jwt.sign(
                {
                  id: agent.id,
                  ip: agent.ip,
                  status: agent.status,
                  current: report.id
                },
                "LOL", 
                { expiresIn: "30d" } 
              );
              console.log(report.id)
            const resp = await axios.post(`http://${agent.ip}:5001/scan`, {
              exploit: {
                vulnerability_id: exploit.vulnerability_id,
                title: exploit.title,
                description: exploit.description,
                publication_date: exploit.publication_date,
                source_link: exploit.source_link,
                score: exploit.score,
                type: exploit.type,
              },
              service: {
                name: task.service.name,
                id: task.service.id,
              },
              token
            });

            console.log(resp.data, "LOL")
  
            console.log(`Task sent successfully to Agent ${agent.id} for Service ${task.service.name}`);

            break 
          } catch (error: any) {
            console.error(`Failed to send task to Agent ${agent.id} for Service ${task.service.name}:`, error.message);
          }
        }
      }
  
      console.log("All tasks distributed successfully.");
    } catch (err: any) {
      console.error("Error in fetchLatest process:", err.message);
    }
  };
  
  const executeCurl = (command: string): Promise<string> => {
    return new Promise((resolve, reject) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(`Error executing curl: ${stderr || error.message}`);
          return;
        }
        resolve(stdout);
      });
    });
  };

const determineTechnology = async (data: SploitusResponse) => {
    const messages = [
        {
            "role": "system",
"content": `
You are an expert in cybersecurity and software technologies. Your task is to analyze 
a list of exploits and identify the specific technologies, software, or systems they are associated
 with based on their descriptions. For each exploit, provide a JSON object containing the exploit 
 ID and a list of associated technologies. Use the following rules for your response: \n\n1. 
 Return the output as a list of objects, strictly following this format: {\"id\": \"ExploitID\",
  \"technologies\": [\"technology_1\", \"technology_2\"]}.\n2. Use only lowercase letters for
   technology names.\n3. Replace spaces in technology names with underscores ('_').\n4. Exclude 
   versions (e.g., 'apache_2.4' should be 'apache').\n5. Return only a strictly RFC8259-compliant
    JSON array without any explanation, prefix, or additional text.\n6. Do not use markdown 
    formatting in your response.\n\n### Example Input:\nIf the input list contains the following
     exploits:\n[\n  {\"id\": \"1\", \"description\": \"Apache HTTP server buffer overflow exploit\"},\n 
      {\"id\": \"2\", \"description\": \"Linux kernel privilege escalation exploit\"}\n]\n\n### Expected 
      Output:\n[\n  {\"id\": \"1\", \"technologies\": [\"apache_http_server\", \"buffer_overflow\"]},\n 
       {\"id\": \"2\", \"technologies\": [\"linux_kernel\", \"privilege_escalation\"]}\n]\n\nAnalyze 
       the provided list of exploits and return a JSON array strictly following these instructions.`
        },
        {
            "role": "user",
            "content": JSON.stringify(data.exploits)
        }       
    ]
    try{
        const response = await axios.post(process.env.AZURE_URL || "", 
            {
                messages,
                "max_tokens":500,
                "temperature":0.5
            },
            {
                headers: {
                    'api-key':process.env.AZURE_KEY || ""
                }
            })
        return response.data.choices[0].message.content 
    }catch(err){
        console.error(err)
    }
}

export interface SploitusResponse{
    exploits_total: number 
    exploits: {
        title: string 
        score: number 
        href: string 
        type: string 
        published: string 
        id: string 
        source: string 
        language: string 
    }[]
}

const transformExploits = (responseData: SploitusResponse): Array<{
    vulnerability_id: string;
    title: string;
    description: string;
    publication_date: string;
    source_link: string;
    score: number;
    type: string;
  }> => {
    return responseData.exploits.map((exploit) => ({
      vulnerability_id: exploit.id,
      title: exploit.title,
      description: exploit.source, 
      publication_date: exploit.published,
      source_link: exploit.href,
      score: exploit.score,
      type: exploit.type,
    }));
  };