import axios from "axios";
import cloudscraper from "cloudscraper";
import { exec } from "child_process";
import prisma from "./prisma";

export const fetchLatest = async () => {
    try {      
      const curlCommand = `curl -X POST https://sploitus.com/search -H "Content-Type: application/json" -d '{"type":"exploits","sort":"default","query":"POC","title":false,"offset":0}'`;
  
      const response = await executeCurl(curlCommand);
        
      const responseData = JSON.parse(response);
      const transformedExploits = transformExploits(responseData);
      
      const technologiesString = await determineTechnology(responseData);
      const technologies = JSON.parse(technologiesString)
      console.log("Technologies:", technologies);

      for (const exp of transformedExploits){
        await prisma.exploit.create({
            data: exp
        })
      }

      const toDo: Array<{ service: any; id: string }> = [];

    for (const techn of technologies) {
    for (const n of techn.technologies) {
        const potentialServices = await prisma.technology.findMany({
        where: {
            name: {
            contains: n,
            mode: 'insensitive',
            },
        },
        });

        for (const service of potentialServices) {
        toDo.push({
            service,
            id: techn.id,
        });
        }
    }
    }

    const agents = await prisma.agent.findMany({
    where: {
        status: "alive",
    },
    });

    for (const task of toDo) {
    for (const agent of agents) {
        try {
        // Retrieve the exploit associated with the current task ID
        const exploit = await prisma.exploit.findFirst({
            where: {
            vulnerability_id: task.id,
            },
        });

        if (!exploit) {
            console.error(`No exploit found for task ID: ${task.id}`);
            continue;
        }

        await axios.post(`http://${agent.ip}:5001/scan`, {
            exploit: {
            vulnerability_id: exploit.vulnerability_id,
            title: exploit.title,
            description: exploit.description,
            publication_date: exploit.publication_date,
            source_link: exploit.source_link,
            score: exploit.score,
            type: exploit.type,
            },
            service: {
            name: task.service.name,
            id: task.service.id,
            },
        });

        console.log(`Task sent to Agent ${agent.id} for Service ${task.service.name}`);
        } catch (error: any) {
        console.error(`Failed to send task to Agent ${agent.id}:`, error.message);
        }
    }
    }

      

      // go through each technology mentioned and search for potential vulnerable services. 

      
    } catch (err: any) {
      console.error("Error:", err.message);
    }
  };

  const executeCurl = (command: string): Promise<string> => {
    return new Promise((resolve, reject) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(`Error executing curl: ${stderr || error.message}`);
          return;
        }
        resolve(stdout);
      });
    });
  };

const determineTechnology = async (data: SploitusResponse) => {
    const messages = [
        {
            "role": "system",
"content": "You are an expert in cybersecurity and software technologies. Your task is to analyze a list of exploits and identify the specific technologies, software, or systems they are associated with based on their descriptions. For each exploit, provide a JSON object containing the exploit ID and a list of associated technologies. Use the following rules for your response: \n\n1. Return the output as a list of objects, strictly following this format: {\"id\": \"ExploitID\", \"technologies\": [\"technology_1\", \"technology_2\"]}.\n2. Use only lowercase letters for technology names.\n3. Replace spaces in technology names with underscores ('_').\n4. Exclude versions (e.g., 'apache_2.4' should be 'apache').\n5. Return only a strictly RFC8259-compliant JSON array without any explanation, prefix, or additional text.\n6. Do not use markdown formatting in your response.\n\n### Example Input:\nIf the input list contains the following exploits:\n[\n  {\"id\": \"1\", \"description\": \"Apache HTTP server buffer overflow exploit\"},\n  {\"id\": \"2\", \"description\": \"Linux kernel privilege escalation exploit\"}\n]\n\n### Expected Output:\n[\n  {\"id\": \"1\", \"technologies\": [\"apache_http_server\", \"buffer_overflow\"]},\n  {\"id\": \"2\", \"technologies\": [\"linux_kernel\", \"privilege_escalation\"]}\n]\n\nAnalyze the provided list of exploits and return a JSON array strictly following these instructions."
        },
        {
            "role": "user",
            "content": JSON.stringify(data.exploits)
        }       
    ]
    try{
        const response = await axios.post(process.env.AZURE_URL || "", 
            {
                messages,
                "max_tokens":500,
                "temperature":0.5
            },
            {
                headers: {
                    'api-key':process.env.AZURE_KEY || ""
                }
            })
        return response.data.choices[0].message.content 
    }catch(err){
        console.error(err)
    }
}

export interface SploitusResponse{
    exploits_total: number 
    exploits: {
        title: string 
        score: number 
        href: string 
        type: string 
        published: string 
        id: string 
        source: string 
        language: string 
    }[]
}

const transformExploits = (responseData: SploitusResponse): Array<{
    vulnerability_id: string;
    title: string;
    description: string;
    publication_date: string;
    source_link: string;
    score: number;
    type: string;
  }> => {
    return responseData.exploits.map((exploit) => ({
      vulnerability_id: exploit.id,
      title: exploit.title,
      description: exploit.source, 
      publication_date: exploit.published,
      source_link: exploit.href,
      score: exploit.score,
      type: exploit.type,
    }));
  };